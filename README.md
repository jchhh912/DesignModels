## More
    设计模式的设计原则：每种设计原则，都是一些经验的总结，设计初衷都是为了解决编程问题或一些应用场景.
	1.单一职责原则
		对于一个类而言，应该有仅有一个引起变化的原因，如果一个类承担的职责过多，将增加耦合度，当发生变化时，设计会遭受意想不到的破坏。
	2.开发-封闭原则
		开放-封闭原则是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。
		对于扩展开放，对于更改封闭
	3.依赖倒转原则
		高层模块不应该依赖低层模块，应该依赖抽象模块
		抽象不能依赖细节，细节应该依赖抽象。列如基于接口编程
	4.里氏代换原则
		子类型必须能够替换掉父类型
	5.接口隔离原则
		使用多个隔离的接口，比使用单个接口好，建立最小的接口，每个接口负责一个功能。
	6.迪米特法则
		如果两个类不彼此通信，那么这两个类就不应当发生直接的相互作用。如果一个类要调用另一个类的某个方法，可以通过第三者转发这个调用。
		类的结构设计，每一个类都应当尽量降低成员的访问权限
		类的耦合度越低，复用率越高，当修改一个类时不会对当前关系的类造成破坏。
	7.组合由于继承
		多用组合，而非继承，因为继承会引入很多不必要的东西，利用组合还能解决层次过深，过复杂的继承关系，有利于代码维护，许多语言设计是不允许多继承的，C#为单继承语言，一个类只能拥有一个父类。
		继承的三个作用：以下三个作用都可通过组合，接口，委托来实现
			1.表示is-a关系
			2.支持多态特性
			3.代码复用
	抽象工厂的工厂是类；工厂方法的工厂是方法。
    抽象工厂关键在于产品之间的抽象关系，所以一般至少要两个产品；工厂方法在于生成产品，不关注产品间的关系，所以可以只生成一个产品。

## 设计模式
	创建型:
		常用:单例模式,工厂模式(工厂方法和抽象工厂),建造者模式
		不常用:原型模式
	结构型：
		常用：代理模式,桥接模式,装饰者模式,适配器模式
		不常用：门面模式,组合模式,享元模式
	行为型：
		常用：观察者模式,模板模式,策略模式,职责链模式,迭代器模式,状态模式
		不常用：访问者模式,备忘录模式,命令模式,解释器模式,中介模式
## 创建型模式
	判断是否使用方法
		封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
		代码复用：创建代码抽离到独立的工厂类之后可以复用。
		隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
		控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。
	1.简单工厂(Simple Factory)：一个工厂对象决定创建出哪一种类型的实例。但每次新增类型都需要修改工厂内部代码，不符合开闭原则
		
	2.抽象工厂(Abstract Factory)：提供一系列相关或相互依赖对象的接口，而无需指定他们具体的类,我们可以通过方法来识别该模式——其会返回一个工厂对象，接下来，工厂将被用于创建特定的子组件。
	  例如：在开发中需要数据库连接，我们有一系列数据库类型，所有数据库都实现IDbFactory接口，通过抽象接口调用工厂，无需了解工厂类，只需要调用IDbFactory 接口就实现相应数据库的操作。
	  实现方法：
		  以不同的产品类型与产品变体为维度绘制矩阵。
		  为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口。
		  声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法。
		  为每种产品变体实现一个具体工厂类。
		  在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类。
		  找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

	  应用场景：
	      如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，可以使用抽象工厂。
		  如果有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。
	 
	  优点：可以确保同一工厂生成的产品相互匹配。										缺点：由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂。
		    可以避免客户端和具体产品代码的耦合。
			单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护。
			开闭原则。向应用程序中引入新产品变体时，你无需修改客户端代码。

	3.工厂方法(Factory Method):定义一个用于创建对象的接口，让子类决定实例化哪一个类。和简单工厂相比，简单工厂的选择判断是在工厂内部，而工厂方法则将选择判断转移到了客户端。
	  例如：举例来说,实习生Undergradute和志愿者Volunteer类都必须实现工作Wroking接口，该接口声明了三种类型的工作Sweep，Wash，BuyRice。每个类都将以不同的方式实现该方法进行工作。UndergraduteFactory类中的工厂方法返回大学生对象，VolunteerFactory类则返回志愿者对象。
	  实现方法：
		  让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。
		  在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。
		  在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
		  工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符，用于选择各种需要实例化的产品类。但是不要担心，我们很快就会修复这个问题。
		  现在，为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。
	      如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时也可以在子类中复用基类中的控制参数。

	  应用场景：
		  在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
		  希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
		  希望复用现有对象来节省系统资源， 而不是每次都重新创建对象，可使用工厂方法。

	  优点：避免创建者和具体产品之间的紧密耦合。                                 缺点：应用工厂方法模式需要引入许多新的子类，代码会复杂，最好将该模式映入创建者模式的现有层次结构中。
		   单一职责原则，使代码更容易维护。
		   开闭原则，无需改变现有客户端就可以引入新的产品类型。

	4.建造者模式(Builder Method):隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。
	  例如：创建一个房屋House对象，创建一栋简单的房屋，建造墙和地板，房门和窗户，屋顶。将对象构造代码从产品类中抽取除了，放在生成器的独立对象中。每次都通过生成器执行一系列步骤，选择特定的配置即可
      实现方法：
		  清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。
		  在基本生成器接口中声明这些步骤。
		  为每个形式的产品创建具体生成器类， 并实现其构造步骤。
		  不要忘记实现获取构造结果对象的方法。不能在生成器接口中声明该方法，因为不同生成器构造的产品可能没有公共接口，因此就不知道该方法返回的对象类型。但是，如果所有产品都位于单一类层次中，你就可以安全地在基本接口中添加获取生成对象的方法。
		  考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。
		  客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需调用主管类构造函数一次即可。主管类使用生成器对象完成后续所有制造任务。还有另一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。
	  
	  应用场景：
		  使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。
		  希望使用代码创建不同形式但属性相同的产品 （例如石头或木头房屋，电脑）时， 可使用生成器模式。
		  使用生成器构造组合树或其他复杂对象。
	  优点：可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。					缺点：由于该模式需要新增多个类
			生成不同形式的产品时， 你可以复用相同的制造代码。
			单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。
		只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则当添加一个新属性时，所有的生成器都需要修改。

	5.单例模式(Singleton Method):能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
	 例如：1.政府是单例模式的一个很好的例子。一个国家只有一个官方政府。不管组成政府的每个人的身份是什么，“某政府”这称谓总是鉴别那些掌权的全局访问节点。
		   2.处理资源访问冲突，比如说上面说的系统唯一硬件，系统文件访问冲突等
	 实现方法：
		在类中添加一个私有静态成员变量用于保存单例实例。
		声明一个公有静态构建方法用于获取单例实例。
		在静态方法中实现"延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。
		将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。
		检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。
	
	 应用场景：
		如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。
		如果你需要更加严格地控制全局变量， 可以使用单例模式。

	 优点：保证一个类只有一个实例								缺点：违法单一职责原则
		  获得一个指向该实例的全局访问节点							  单例模式可能掩盖不良设计，比如组件之间互相了解过多	
		  首次请求单例对象时对其初始化								  单例模式在多线程下需要特殊处理，避免多个线程多次创建单例对象
																  单例模式的客户端代码单元测试比较困难，因为许多测试框架基于继承方式创建模拟对象。由于单例构造函数是私有的，绝大部语言无法重写静态方法，要么不写测试代码要么不使用单例模式。
	
	6.原型/克隆模式(Prototype/Clone Method):原型模式其实就是从一个对象再创建另外一个可定制的对象而且不需要知道任何创建的细节。
	  例如：《西游记》中孙悟空可以拔毛变小猴，孙悟空可以根据自己的形象复制出很多和自己长得一模一样的身外身来。孙悟空这种根据自己的形象复制出身外身的技巧在软件设计中就是原型模式。
	  实现方法：
		  1.创建原型接口，并在其中声明 克隆方法。如果你已有类层次结构，则只需在其所有类中添加该方法即可。
		  2.原型类必须另行定义一个以该类对象为参数的构造函数。构造函数必须复制参数对象中的所有成员变量值到新建实体中。如果你需要修改子类，则必须调用父类构造函数，让父类复制其私有成员变量值。
		  3.克隆方法通常只有一行代码：使用new运算符调用原型版本的构造函数。注意，每个类都必须显式重写克隆方法并使用自身类名调用new运算符。否则克隆方法可能会生成父类的对象。
		  4.还可以创建一个中心化原型注册表， 用于存储常用原型.

	  应用场景:如果需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。
			  如果子类的区别仅限于对象的初始化方式，那么可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象。
	  
	  浅拷贝：克隆对象和原对象共享引用类型的变量 （引用类型同指向一个内存）
	  深拷贝：克隆一个对象时依次克隆它的实例变量 （所有数据间没有任何关系）
	  可以简单理解为，浅拷贝是List<int> a = new List<int>(); List<int> b = a; , 集合a，b同指向一个内存修改a中的值即修改了b中的值；
	  而深拷贝是List<int> a = new List<int>(); List<int> b = new List<int>(a); new了一个集合b并且将a中的数据全部复制过去了，此时a，b没有任何关系。
	
	  优点：你可以克隆对象， 而无需与它们所属的具体类相耦合。	缺点：克隆包含循环引用的复杂对象可能会非常麻烦。
			你可以克隆预生成原型， 避免反复运行初始化代码。		
			你可以更方便地生成复杂对象。
			你可以用继承以外的方式来处理复杂对象的不同配置。
## 结构型模型
	结构型模式：
		介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。
	1.适配器(Adapter Method):让接口不兼容的对象能够相互合作。
		Target: 一个标准模式的类型，标准化接口
		Adaptee: 一个需要适配的类型，特殊类型
		TargetAdapter: Adaptee 针对 Target 的适配器
	例如：国内的充电器到了欧美国家插头可能不适配，这个时候就需要适配器
	当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。
	实现方法：
		1.确保至少有两个类的接口不兼容：
				一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。
				一个或多个将受益于使用服务类的客户端类。
		2.声明客户端接口， 描述客户端如何与服务交互。
		3.创建遵循客户端接口的适配器类。 所有方法暂时都为空。
		4.在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。
		5.依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。
		6.客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。
	应用场景:当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。
			如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。
	优点：单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。					缺点：代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。
		 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。
	
	2.桥接模式(Bridge Method):可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。
	   （1）、抽象化角色(Abstraction)：抽象化给出的定义，并保存一个对实现化对象（Implementor）的引用。
       （2）、修正抽象化角色(Refined Abstraction)：扩展抽象化角色，改变和修正父类对抽象化的定义。
       （3）、实现化角色(Implementor)：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。
       （4）、具体实现化角色(Concrete Implementor)：这个角色给出实现化角色接口的具体实现。
	例如：假如你有一个几何 形状Shape类，从它能扩展出两个子类： ​圆形Circle和方形Square。你希望对这样的类层次结构进行扩展以使其包含颜色，所以你打算创建名为红色Red和蓝色Blue的形状子类。但是， 由于你已有两个子类，所以总共需要创建四个类才能覆盖所有组合，例如蓝色圆形Blue­Circle和红色方形Red­Square 。
	实现方法：
		1.明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。
		2.了解客户端的业务需求， 并在抽象基类中定义它们。
		3.确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。
		4.为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。
		5.在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。
		6.如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。
		7.客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。
	应用场景： 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。
			  如果你希望在几个独立维度上扩展一个类，可使用该模式。
			  如果你需要在运行时切换不同实现方法， 可使用桥接模式。
	优点： 你可以创建与平台无关的类和程序。										缺点：对高内聚的类使用该模式可能会让代码更加复杂。
		   客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。
		   开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。
		   单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。
